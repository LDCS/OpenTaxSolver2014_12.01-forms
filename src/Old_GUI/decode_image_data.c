/********************************************************************************/
/* Decode_Image_Data.c - The routines in this file are used to convert 		*/
/*	image-data embedded within a C-program data structure into a form that	*/
/*	can be displayed by OTK.  They are called by run-time OTK applications	*/
/*	to display images without referencing external image-files at run-time.	*/
/*	It assumes that images were processed with "image2code", and the 	*/
/*	resulting data structures included in the application program.		*/
/********************************************************************************/


/*-------------------------- Core Re-Usable Routines -------------------------------*/
/* ---										--- */

unsigned char byte_decode( unsigned char byte )
{ /* Reverse byte_encode. Converts printable character to original integer range. */
 if (byte < 65) return ((byte - 48) << 2) + 1;
 if (byte < 97) return ((byte - 55) << 2) + 1;
 else return ((byte - 61) << 2) + 1;
}


unsigned char byte_decode64( unsigned char byte )
{ /* Reverse what byte_encode64 did. Convert printable character to integer range. */
 if (byte < 65) return (byte - 48);
 if (byte < 97) return (byte - 55);
 else return (byte - 61);
}


/*-----------------------------------------------------------------------------------------------*/
/* Decode_Image - This routine converts a static data table into an OTK image-object for 	 */
/*  display all within a single C-program, without referencing external image files at run-time. */
/*  The static data table structure (imgmtrxbytes) should have been generated by the Image2Code	 */
/*  program by processing an image.								 */
/*-----------------------------------------------------------------------------------------------*/
struct Otk_image_rec *decode_image( int imgmtrx_N, int nrows, int ncols, unsigned char *imgmtrxbytes )
{ 
 char *imgbytes;
 int j, k=0, mm=0, nn=0, rl, maxn;
 unsigned int last_r, last_g, last_b;
 unsigned int r, g, b;

 /* First check the initial magic format numbers. */
 r = imgmtrxbytes[mm++];
 g = imgmtrxbytes[mm++];
 b = imgmtrxbytes[mm++];
 if ((r != '1') || (g != '1') || ((b != '1') && (b != '2')))
  { printf("Unexpected decode_image magic numbers (%d,%d,%d)\n", r, g, b );  exit(1); }
 imgmtrx_N = imgmtrx_N + 3;
 maxn = ncols * nrows * sizeof( struct Otk_image_rec );
 imgbytes = (char *)malloc( maxn );
 if (b == '1')
  { /*straight_coded*/
    // printf("Straight Decode.\n");
    while (mm < imgmtrx_N)
     {
      imgbytes[nn++] = byte_decode( imgmtrxbytes[mm++] );
      imgbytes[nn++] = byte_decode( imgmtrxbytes[mm++] );
      imgbytes[nn++] = byte_decode( imgmtrxbytes[mm++] );
     }
  } /*straight_coded*/
 else
  { /*run_length_code*/
    // printf("Run-Length Decode.\n");
    while (mm < imgmtrx_N)
     {
      last_r = byte_decode( imgmtrxbytes[mm++] );
      last_g = byte_decode( imgmtrxbytes[mm++] );
      last_b = byte_decode( imgmtrxbytes[mm++] );
      rl = byte_decode64( imgmtrxbytes[mm++] );
      for (j=0; j <= rl; j++)
       {
	imgbytes[nn++] = last_r;
	imgbytes[nn++] = last_g;
	imgbytes[nn++] = last_b;
       }
      if (nn > maxn)
	{ printf("nn = %d > %d. (mm=%d < %d=imgntrx_N)\n", nn, maxn, mm, imgmtrx_N );  exit(1); }
     }

  } /*run_length_code*/

 /* Finally, check the end-marker magic numerals. */
 r = imgmtrxbytes[mm++];
 g = imgmtrxbytes[mm++];
 b = imgmtrxbytes[mm++];
 if ((r != '3') || (g != '2') || (b != '1'))
  { printf("Unexpected decode_image end-marker numbers (%d,%d,%d)\n", r, g, b );  /* exit(1); */ }
 // else printf("Image Decoded OK!\n");

 return (struct Otk_image_rec *)imgbytes;
}

/* ---										    --- */
/*-------------------------- End Core Re-Usable Routines -------------------------------*/
